image: docker:latest

# When using dind, it's wise to use the overlayfs driver for
# improved performance.
variables:
  DOCKER_DRIVER: overlay

services:
  - docker:dind

before_script:
  - apk update && apk add wget bash python && rm -rf /var/cache/apk/*
  - wget https://dl.google.com/dl/cloudsdk/release/google-cloud-sdk.tar.gz --no-check-certificate
  - tar zxvf google-cloud-sdk.tar.gz
  - rm google-cloud-sdk.tar.gz
  - ls -l
  - ./google-cloud-sdk/install.sh --usage-reporting=true --path-update=true
  - export PATH=$(pwd)/google-cloud-sdk/bin:$PATH
  - gcloud --quiet components update
  - echo "$GCLOUD_GITLAB_CI_SERVICE_ACCOUNT_KEY" | base64 -d > gcloud.p12
  - gcloud auth activate-service-account "$GCLOUD_GITLAB_CI_SERVICE_ACCOUNT" --key-file=gcloud.p12  --project "$GCLOUD_PROJECT" --quiet

after_script:
  # clean up
  - rm -rf *

build:
  stage: build
  script:
    - docker build --pull -t "$CI_REGISTRY_IMAGE:${CI_BUILD_TAG:-latest}" .
    - gcloud docker -- push "$CI_REGISTRY_IMAGE:${CI_BUILD_TAG:-latest}"

deploy_branch:
  stage: deploy
  script:
    - gcloud --quiet components install kubectl
    - export GOOGLE_APPLICATION_CREDENTIALS=$(pwd)/gcloud.p12
    - gcloud --quiet container clusters get-credentials $CLUSTER_NAME --zone $GCLOUD_ZONE
    # Don't use public load balancing for development branches
    - sed -i.bak 's#LoadBalancer#ClusterIP#' ./k8s/services/frontend.yaml
    # Create namespace if it doesn't exist
    - kubectl get ns ${CI_BUILD_REF_SLUG} || kubectl create ns ${CI_BUILD_REF_SLUG}
    - kubectl apply --namespace=${CI_BUILD_REF_SLUG} -f k8s/services/ --record
    - kubectl apply --namespace=${CI_BUILD_REF_SLUG} -f k8s/dev/ --record
    - kubectl set image deployment/hello-deployment hellonode=$CI_REGISTRY_IMAGE:${CI_BUILD_TAG:-latest} --namespace=${CI_BUILD_REF_SLUG}
    - echo 'To access your environment run `kubectl proxy`'
    - echo "Then access your service via http://localhost:8001/api/v1/proxy/namespaces/${CI_BUILD_REF_SLUG}/services/hello-deployment-frontend:80/"
  environment:
    name: review/$CI_BUILD_REF_NAME
    url: http://localhost:8001/api/v1/proxy/namespaces/$CI_BUILD_REF_SLUG/services/hello-deployment-frontend:80/
  only:
    - branches
  except:
    - master

deploy_staging:
  stage: deploy
  script:
    - kubectl get ns staging || kubectl create ns staging
    - gcloud --quiet components install kubectl
    - export GOOGLE_APPLICATION_CREDENTIALS=$(pwd)/gcloud.p12
    - gcloud --quiet container clusters get-credentials $CLUSTER_NAME --zone $GCLOUD_ZONE
    - kubectl apply --namespace=staging -f k8s/services/ --record
    - kubectl apply --namespace=staging -f k8s/staging/ --record
    - kubectl set image deployment/hello-deployment hellonode=$CI_REGISTRY_IMAGE:${CI_BUILD_TAG:-latest} --namespace=staging
    - export DOMAIN=`kubectl --namespace=production get service/hello-deployment-frontend --output=json | jq -r '.status.loadBalancer.ingress[0].ip'`
  environment:
    name: staging
    url: http://$DOMAIN
  only:
    - master

deploy_production:
  stage: deploy
  script:
    - kubectl get ns production || kubectl create ns production
    - gcloud --quiet components install kubectl
    - export GOOGLE_APPLICATION_CREDENTIALS=$(pwd)/gcloud.p12
    - gcloud --quiet container clusters get-credentials $CLUSTER_NAME --zone $GCLOUD_ZONE
    - kubectl apply --namespace=production -f k8s/services/ --record
    - kubectl apply --namespace=production -f k8s/production/ --record
    - kubectl set image deployment/hello-deployment hellonode=$CI_REGISTRY_IMAGE:${CI_BUILD_TAG:-latest} --namespace=production
    - export DOMAIN=`kubectl --namespace=production get service/hello-deployment-frontend --output=json | jq -r '.status.loadBalancer.ingress[0].ip'`
  environment:
    name: production
    url: http://$DOMAIN
  when: manual
  only:
    - master
